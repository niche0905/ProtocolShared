// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lobby/lobby_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_lobby_2flobby_5fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_lobby_2flobby_5fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "options/packet_options.pb.h"
#include "common/common_types.pb.h"
#include "lobby/lobby_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_lobby_2flobby_5fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_lobby_2flobby_5fmessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_lobby_2flobby_5fmessages_2eproto;
namespace se {
namespace lobby {
class C_LobbyEnterReq;
struct C_LobbyEnterReqDefaultTypeInternal;
extern C_LobbyEnterReqDefaultTypeInternal _C_LobbyEnterReq_default_instance_;
class C_MatchQueueCancelReq;
struct C_MatchQueueCancelReqDefaultTypeInternal;
extern C_MatchQueueCancelReqDefaultTypeInternal _C_MatchQueueCancelReq_default_instance_;
class C_MatchQueueEnterReq;
struct C_MatchQueueEnterReqDefaultTypeInternal;
extern C_MatchQueueEnterReqDefaultTypeInternal _C_MatchQueueEnterReq_default_instance_;
class N_MatchFound;
struct N_MatchFoundDefaultTypeInternal;
extern N_MatchFoundDefaultTypeInternal _N_MatchFound_default_instance_;
class S_LobbyEnterRes;
struct S_LobbyEnterResDefaultTypeInternal;
extern S_LobbyEnterResDefaultTypeInternal _S_LobbyEnterRes_default_instance_;
class S_MatchQueueCancelRes;
struct S_MatchQueueCancelResDefaultTypeInternal;
extern S_MatchQueueCancelResDefaultTypeInternal _S_MatchQueueCancelRes_default_instance_;
class S_MatchQueueEnterRes;
struct S_MatchQueueEnterResDefaultTypeInternal;
extern S_MatchQueueEnterResDefaultTypeInternal _S_MatchQueueEnterRes_default_instance_;
}  // namespace lobby
}  // namespace se
PROTOBUF_NAMESPACE_OPEN
template<> ::se::lobby::C_LobbyEnterReq* Arena::CreateMaybeMessage<::se::lobby::C_LobbyEnterReq>(Arena*);
template<> ::se::lobby::C_MatchQueueCancelReq* Arena::CreateMaybeMessage<::se::lobby::C_MatchQueueCancelReq>(Arena*);
template<> ::se::lobby::C_MatchQueueEnterReq* Arena::CreateMaybeMessage<::se::lobby::C_MatchQueueEnterReq>(Arena*);
template<> ::se::lobby::N_MatchFound* Arena::CreateMaybeMessage<::se::lobby::N_MatchFound>(Arena*);
template<> ::se::lobby::S_LobbyEnterRes* Arena::CreateMaybeMessage<::se::lobby::S_LobbyEnterRes>(Arena*);
template<> ::se::lobby::S_MatchQueueCancelRes* Arena::CreateMaybeMessage<::se::lobby::S_MatchQueueCancelRes>(Arena*);
template<> ::se::lobby::S_MatchQueueEnterRes* Arena::CreateMaybeMessage<::se::lobby::S_MatchQueueEnterRes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace se {
namespace lobby {

// ===================================================================

class C_LobbyEnterReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:se.lobby.C_LobbyEnterReq) */ {
 public:
  inline C_LobbyEnterReq() : C_LobbyEnterReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LobbyEnterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LobbyEnterReq(const C_LobbyEnterReq& from);
  C_LobbyEnterReq(C_LobbyEnterReq&& from) noexcept
    : C_LobbyEnterReq() {
    *this = ::std::move(from);
  }

  inline C_LobbyEnterReq& operator=(const C_LobbyEnterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LobbyEnterReq& operator=(C_LobbyEnterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LobbyEnterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LobbyEnterReq* internal_default_instance() {
    return reinterpret_cast<const C_LobbyEnterReq*>(
               &_C_LobbyEnterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_LobbyEnterReq& a, C_LobbyEnterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LobbyEnterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LobbyEnterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LobbyEnterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LobbyEnterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LobbyEnterReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LobbyEnterReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.lobby.C_LobbyEnterReq";
  }
  protected:
  explicit C_LobbyEnterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:se.lobby.C_LobbyEnterReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_lobby_2flobby_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class S_LobbyEnterRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.lobby.S_LobbyEnterRes) */ {
 public:
  inline S_LobbyEnterRes() : S_LobbyEnterRes(nullptr) {}
  ~S_LobbyEnterRes() override;
  explicit PROTOBUF_CONSTEXPR S_LobbyEnterRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LobbyEnterRes(const S_LobbyEnterRes& from);
  S_LobbyEnterRes(S_LobbyEnterRes&& from) noexcept
    : S_LobbyEnterRes() {
    *this = ::std::move(from);
  }

  inline S_LobbyEnterRes& operator=(const S_LobbyEnterRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LobbyEnterRes& operator=(S_LobbyEnterRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LobbyEnterRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LobbyEnterRes* internal_default_instance() {
    return reinterpret_cast<const S_LobbyEnterRes*>(
               &_S_LobbyEnterRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_LobbyEnterRes& a, S_LobbyEnterRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LobbyEnterRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LobbyEnterRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LobbyEnterRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LobbyEnterRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LobbyEnterRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LobbyEnterRes& from) {
    S_LobbyEnterRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LobbyEnterRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.lobby.S_LobbyEnterRes";
  }
  protected:
  explicit S_LobbyEnterRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kProfileFieldNumber = 2,
  };
  // .se.common.Result result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::se::common::Result& result() const;
  PROTOBUF_NODISCARD ::se::common::Result* release_result();
  ::se::common::Result* mutable_result();
  void set_allocated_result(::se::common::Result* result);
  private:
  const ::se::common::Result& _internal_result() const;
  ::se::common::Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::se::common::Result* result);
  ::se::common::Result* unsafe_arena_release_result();

  // .se.lobby.PlayerProfile profile = 2;
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  const ::se::lobby::PlayerProfile& profile() const;
  PROTOBUF_NODISCARD ::se::lobby::PlayerProfile* release_profile();
  ::se::lobby::PlayerProfile* mutable_profile();
  void set_allocated_profile(::se::lobby::PlayerProfile* profile);
  private:
  const ::se::lobby::PlayerProfile& _internal_profile() const;
  ::se::lobby::PlayerProfile* _internal_mutable_profile();
  public:
  void unsafe_arena_set_allocated_profile(
      ::se::lobby::PlayerProfile* profile);
  ::se::lobby::PlayerProfile* unsafe_arena_release_profile();

  // @@protoc_insertion_point(class_scope:se.lobby.S_LobbyEnterRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::common::Result* result_;
    ::se::lobby::PlayerProfile* profile_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lobby_2flobby_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class C_MatchQueueEnterReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.lobby.C_MatchQueueEnterReq) */ {
 public:
  inline C_MatchQueueEnterReq() : C_MatchQueueEnterReq(nullptr) {}
  ~C_MatchQueueEnterReq() override;
  explicit PROTOBUF_CONSTEXPR C_MatchQueueEnterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MatchQueueEnterReq(const C_MatchQueueEnterReq& from);
  C_MatchQueueEnterReq(C_MatchQueueEnterReq&& from) noexcept
    : C_MatchQueueEnterReq() {
    *this = ::std::move(from);
  }

  inline C_MatchQueueEnterReq& operator=(const C_MatchQueueEnterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MatchQueueEnterReq& operator=(C_MatchQueueEnterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MatchQueueEnterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MatchQueueEnterReq* internal_default_instance() {
    return reinterpret_cast<const C_MatchQueueEnterReq*>(
               &_C_MatchQueueEnterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_MatchQueueEnterReq& a, C_MatchQueueEnterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MatchQueueEnterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MatchQueueEnterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MatchQueueEnterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MatchQueueEnterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MatchQueueEnterReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MatchQueueEnterReq& from) {
    C_MatchQueueEnterReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MatchQueueEnterReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.lobby.C_MatchQueueEnterReq";
  }
  protected:
  explicit C_MatchQueueEnterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaylistIdFieldNumber = 1,
  };
  // uint32 playlist_id = 1;
  void clear_playlist_id();
  uint32_t playlist_id() const;
  void set_playlist_id(uint32_t value);
  private:
  uint32_t _internal_playlist_id() const;
  void _internal_set_playlist_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:se.lobby.C_MatchQueueEnterReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t playlist_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lobby_2flobby_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class S_MatchQueueEnterRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.lobby.S_MatchQueueEnterRes) */ {
 public:
  inline S_MatchQueueEnterRes() : S_MatchQueueEnterRes(nullptr) {}
  ~S_MatchQueueEnterRes() override;
  explicit PROTOBUF_CONSTEXPR S_MatchQueueEnterRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MatchQueueEnterRes(const S_MatchQueueEnterRes& from);
  S_MatchQueueEnterRes(S_MatchQueueEnterRes&& from) noexcept
    : S_MatchQueueEnterRes() {
    *this = ::std::move(from);
  }

  inline S_MatchQueueEnterRes& operator=(const S_MatchQueueEnterRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MatchQueueEnterRes& operator=(S_MatchQueueEnterRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MatchQueueEnterRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MatchQueueEnterRes* internal_default_instance() {
    return reinterpret_cast<const S_MatchQueueEnterRes*>(
               &_S_MatchQueueEnterRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_MatchQueueEnterRes& a, S_MatchQueueEnterRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MatchQueueEnterRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MatchQueueEnterRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MatchQueueEnterRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MatchQueueEnterRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MatchQueueEnterRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MatchQueueEnterRes& from) {
    S_MatchQueueEnterRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MatchQueueEnterRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.lobby.S_MatchQueueEnterRes";
  }
  protected:
  explicit S_MatchQueueEnterRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kTicketFieldNumber = 2,
  };
  // .se.common.Result result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::se::common::Result& result() const;
  PROTOBUF_NODISCARD ::se::common::Result* release_result();
  ::se::common::Result* mutable_result();
  void set_allocated_result(::se::common::Result* result);
  private:
  const ::se::common::Result& _internal_result() const;
  ::se::common::Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::se::common::Result* result);
  ::se::common::Result* unsafe_arena_release_result();

  // .se.lobby.MatchTicket ticket = 2;
  bool has_ticket() const;
  private:
  bool _internal_has_ticket() const;
  public:
  void clear_ticket();
  const ::se::lobby::MatchTicket& ticket() const;
  PROTOBUF_NODISCARD ::se::lobby::MatchTicket* release_ticket();
  ::se::lobby::MatchTicket* mutable_ticket();
  void set_allocated_ticket(::se::lobby::MatchTicket* ticket);
  private:
  const ::se::lobby::MatchTicket& _internal_ticket() const;
  ::se::lobby::MatchTicket* _internal_mutable_ticket();
  public:
  void unsafe_arena_set_allocated_ticket(
      ::se::lobby::MatchTicket* ticket);
  ::se::lobby::MatchTicket* unsafe_arena_release_ticket();

  // @@protoc_insertion_point(class_scope:se.lobby.S_MatchQueueEnterRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::common::Result* result_;
    ::se::lobby::MatchTicket* ticket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lobby_2flobby_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class C_MatchQueueCancelReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.lobby.C_MatchQueueCancelReq) */ {
 public:
  inline C_MatchQueueCancelReq() : C_MatchQueueCancelReq(nullptr) {}
  ~C_MatchQueueCancelReq() override;
  explicit PROTOBUF_CONSTEXPR C_MatchQueueCancelReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MatchQueueCancelReq(const C_MatchQueueCancelReq& from);
  C_MatchQueueCancelReq(C_MatchQueueCancelReq&& from) noexcept
    : C_MatchQueueCancelReq() {
    *this = ::std::move(from);
  }

  inline C_MatchQueueCancelReq& operator=(const C_MatchQueueCancelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MatchQueueCancelReq& operator=(C_MatchQueueCancelReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MatchQueueCancelReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MatchQueueCancelReq* internal_default_instance() {
    return reinterpret_cast<const C_MatchQueueCancelReq*>(
               &_C_MatchQueueCancelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_MatchQueueCancelReq& a, C_MatchQueueCancelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MatchQueueCancelReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MatchQueueCancelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MatchQueueCancelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MatchQueueCancelReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MatchQueueCancelReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MatchQueueCancelReq& from) {
    C_MatchQueueCancelReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MatchQueueCancelReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.lobby.C_MatchQueueCancelReq";
  }
  protected:
  explicit C_MatchQueueCancelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
  };
  // .se.lobby.MatchTicket ticket = 1;
  bool has_ticket() const;
  private:
  bool _internal_has_ticket() const;
  public:
  void clear_ticket();
  const ::se::lobby::MatchTicket& ticket() const;
  PROTOBUF_NODISCARD ::se::lobby::MatchTicket* release_ticket();
  ::se::lobby::MatchTicket* mutable_ticket();
  void set_allocated_ticket(::se::lobby::MatchTicket* ticket);
  private:
  const ::se::lobby::MatchTicket& _internal_ticket() const;
  ::se::lobby::MatchTicket* _internal_mutable_ticket();
  public:
  void unsafe_arena_set_allocated_ticket(
      ::se::lobby::MatchTicket* ticket);
  ::se::lobby::MatchTicket* unsafe_arena_release_ticket();

  // @@protoc_insertion_point(class_scope:se.lobby.C_MatchQueueCancelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::lobby::MatchTicket* ticket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lobby_2flobby_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class S_MatchQueueCancelRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.lobby.S_MatchQueueCancelRes) */ {
 public:
  inline S_MatchQueueCancelRes() : S_MatchQueueCancelRes(nullptr) {}
  ~S_MatchQueueCancelRes() override;
  explicit PROTOBUF_CONSTEXPR S_MatchQueueCancelRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MatchQueueCancelRes(const S_MatchQueueCancelRes& from);
  S_MatchQueueCancelRes(S_MatchQueueCancelRes&& from) noexcept
    : S_MatchQueueCancelRes() {
    *this = ::std::move(from);
  }

  inline S_MatchQueueCancelRes& operator=(const S_MatchQueueCancelRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MatchQueueCancelRes& operator=(S_MatchQueueCancelRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MatchQueueCancelRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MatchQueueCancelRes* internal_default_instance() {
    return reinterpret_cast<const S_MatchQueueCancelRes*>(
               &_S_MatchQueueCancelRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_MatchQueueCancelRes& a, S_MatchQueueCancelRes& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MatchQueueCancelRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MatchQueueCancelRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MatchQueueCancelRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MatchQueueCancelRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MatchQueueCancelRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MatchQueueCancelRes& from) {
    S_MatchQueueCancelRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MatchQueueCancelRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.lobby.S_MatchQueueCancelRes";
  }
  protected:
  explicit S_MatchQueueCancelRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .se.common.Result result = 1;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::se::common::Result& result() const;
  PROTOBUF_NODISCARD ::se::common::Result* release_result();
  ::se::common::Result* mutable_result();
  void set_allocated_result(::se::common::Result* result);
  private:
  const ::se::common::Result& _internal_result() const;
  ::se::common::Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::se::common::Result* result);
  ::se::common::Result* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:se.lobby.S_MatchQueueCancelRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::common::Result* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lobby_2flobby_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class N_MatchFound final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.lobby.N_MatchFound) */ {
 public:
  inline N_MatchFound() : N_MatchFound(nullptr) {}
  ~N_MatchFound() override;
  explicit PROTOBUF_CONSTEXPR N_MatchFound(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  N_MatchFound(const N_MatchFound& from);
  N_MatchFound(N_MatchFound&& from) noexcept
    : N_MatchFound() {
    *this = ::std::move(from);
  }

  inline N_MatchFound& operator=(const N_MatchFound& from) {
    CopyFrom(from);
    return *this;
  }
  inline N_MatchFound& operator=(N_MatchFound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const N_MatchFound& default_instance() {
    return *internal_default_instance();
  }
  static inline const N_MatchFound* internal_default_instance() {
    return reinterpret_cast<const N_MatchFound*>(
               &_N_MatchFound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(N_MatchFound& a, N_MatchFound& b) {
    a.Swap(&b);
  }
  inline void Swap(N_MatchFound* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(N_MatchFound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  N_MatchFound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<N_MatchFound>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const N_MatchFound& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const N_MatchFound& from) {
    N_MatchFound::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(N_MatchFound* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.lobby.N_MatchFound";
  }
  protected:
  explicit N_MatchFound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
  };
  // .se.lobby.RoomEndpoint room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::se::lobby::RoomEndpoint& room() const;
  PROTOBUF_NODISCARD ::se::lobby::RoomEndpoint* release_room();
  ::se::lobby::RoomEndpoint* mutable_room();
  void set_allocated_room(::se::lobby::RoomEndpoint* room);
  private:
  const ::se::lobby::RoomEndpoint& _internal_room() const;
  ::se::lobby::RoomEndpoint* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::se::lobby::RoomEndpoint* room);
  ::se::lobby::RoomEndpoint* unsafe_arena_release_room();

  // @@protoc_insertion_point(class_scope:se.lobby.N_MatchFound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::lobby::RoomEndpoint* room_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lobby_2flobby_5fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_LobbyEnterReq

// -------------------------------------------------------------------

// S_LobbyEnterRes

// .se.common.Result result = 1;
inline bool S_LobbyEnterRes::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool S_LobbyEnterRes::has_result() const {
  return _internal_has_result();
}
inline const ::se::common::Result& S_LobbyEnterRes::_internal_result() const {
  const ::se::common::Result* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::common::Result&>(
      ::se::common::_Result_default_instance_);
}
inline const ::se::common::Result& S_LobbyEnterRes::result() const {
  // @@protoc_insertion_point(field_get:se.lobby.S_LobbyEnterRes.result)
  return _internal_result();
}
inline void S_LobbyEnterRes::unsafe_arena_set_allocated_result(
    ::se::common::Result* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.lobby.S_LobbyEnterRes.result)
}
inline ::se::common::Result* S_LobbyEnterRes::release_result() {
  
  ::se::common::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::common::Result* S_LobbyEnterRes::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:se.lobby.S_LobbyEnterRes.result)
  
  ::se::common::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::se::common::Result* S_LobbyEnterRes::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::common::Result>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::se::common::Result* S_LobbyEnterRes::mutable_result() {
  ::se::common::Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:se.lobby.S_LobbyEnterRes.result)
  return _msg;
}
inline void S_LobbyEnterRes::set_allocated_result(::se::common::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result));
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:se.lobby.S_LobbyEnterRes.result)
}

// .se.lobby.PlayerProfile profile = 2;
inline bool S_LobbyEnterRes::_internal_has_profile() const {
  return this != internal_default_instance() && _impl_.profile_ != nullptr;
}
inline bool S_LobbyEnterRes::has_profile() const {
  return _internal_has_profile();
}
inline const ::se::lobby::PlayerProfile& S_LobbyEnterRes::_internal_profile() const {
  const ::se::lobby::PlayerProfile* p = _impl_.profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::lobby::PlayerProfile&>(
      ::se::lobby::_PlayerProfile_default_instance_);
}
inline const ::se::lobby::PlayerProfile& S_LobbyEnterRes::profile() const {
  // @@protoc_insertion_point(field_get:se.lobby.S_LobbyEnterRes.profile)
  return _internal_profile();
}
inline void S_LobbyEnterRes::unsafe_arena_set_allocated_profile(
    ::se::lobby::PlayerProfile* profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profile_);
  }
  _impl_.profile_ = profile;
  if (profile) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.lobby.S_LobbyEnterRes.profile)
}
inline ::se::lobby::PlayerProfile* S_LobbyEnterRes::release_profile() {
  
  ::se::lobby::PlayerProfile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::lobby::PlayerProfile* S_LobbyEnterRes::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_release:se.lobby.S_LobbyEnterRes.profile)
  
  ::se::lobby::PlayerProfile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
  return temp;
}
inline ::se::lobby::PlayerProfile* S_LobbyEnterRes::_internal_mutable_profile() {
  
  if (_impl_.profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::lobby::PlayerProfile>(GetArenaForAllocation());
    _impl_.profile_ = p;
  }
  return _impl_.profile_;
}
inline ::se::lobby::PlayerProfile* S_LobbyEnterRes::mutable_profile() {
  ::se::lobby::PlayerProfile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:se.lobby.S_LobbyEnterRes.profile)
  return _msg;
}
inline void S_LobbyEnterRes::set_allocated_profile(::se::lobby::PlayerProfile* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profile_);
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profile));
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:se.lobby.S_LobbyEnterRes.profile)
}

// -------------------------------------------------------------------

// C_MatchQueueEnterReq

// uint32 playlist_id = 1;
inline void C_MatchQueueEnterReq::clear_playlist_id() {
  _impl_.playlist_id_ = 0u;
}
inline uint32_t C_MatchQueueEnterReq::_internal_playlist_id() const {
  return _impl_.playlist_id_;
}
inline uint32_t C_MatchQueueEnterReq::playlist_id() const {
  // @@protoc_insertion_point(field_get:se.lobby.C_MatchQueueEnterReq.playlist_id)
  return _internal_playlist_id();
}
inline void C_MatchQueueEnterReq::_internal_set_playlist_id(uint32_t value) {
  
  _impl_.playlist_id_ = value;
}
inline void C_MatchQueueEnterReq::set_playlist_id(uint32_t value) {
  _internal_set_playlist_id(value);
  // @@protoc_insertion_point(field_set:se.lobby.C_MatchQueueEnterReq.playlist_id)
}

// -------------------------------------------------------------------

// S_MatchQueueEnterRes

// .se.common.Result result = 1;
inline bool S_MatchQueueEnterRes::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool S_MatchQueueEnterRes::has_result() const {
  return _internal_has_result();
}
inline const ::se::common::Result& S_MatchQueueEnterRes::_internal_result() const {
  const ::se::common::Result* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::common::Result&>(
      ::se::common::_Result_default_instance_);
}
inline const ::se::common::Result& S_MatchQueueEnterRes::result() const {
  // @@protoc_insertion_point(field_get:se.lobby.S_MatchQueueEnterRes.result)
  return _internal_result();
}
inline void S_MatchQueueEnterRes::unsafe_arena_set_allocated_result(
    ::se::common::Result* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.lobby.S_MatchQueueEnterRes.result)
}
inline ::se::common::Result* S_MatchQueueEnterRes::release_result() {
  
  ::se::common::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::common::Result* S_MatchQueueEnterRes::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:se.lobby.S_MatchQueueEnterRes.result)
  
  ::se::common::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::se::common::Result* S_MatchQueueEnterRes::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::common::Result>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::se::common::Result* S_MatchQueueEnterRes::mutable_result() {
  ::se::common::Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:se.lobby.S_MatchQueueEnterRes.result)
  return _msg;
}
inline void S_MatchQueueEnterRes::set_allocated_result(::se::common::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result));
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:se.lobby.S_MatchQueueEnterRes.result)
}

// .se.lobby.MatchTicket ticket = 2;
inline bool S_MatchQueueEnterRes::_internal_has_ticket() const {
  return this != internal_default_instance() && _impl_.ticket_ != nullptr;
}
inline bool S_MatchQueueEnterRes::has_ticket() const {
  return _internal_has_ticket();
}
inline const ::se::lobby::MatchTicket& S_MatchQueueEnterRes::_internal_ticket() const {
  const ::se::lobby::MatchTicket* p = _impl_.ticket_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::lobby::MatchTicket&>(
      ::se::lobby::_MatchTicket_default_instance_);
}
inline const ::se::lobby::MatchTicket& S_MatchQueueEnterRes::ticket() const {
  // @@protoc_insertion_point(field_get:se.lobby.S_MatchQueueEnterRes.ticket)
  return _internal_ticket();
}
inline void S_MatchQueueEnterRes::unsafe_arena_set_allocated_ticket(
    ::se::lobby::MatchTicket* ticket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ticket_);
  }
  _impl_.ticket_ = ticket;
  if (ticket) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.lobby.S_MatchQueueEnterRes.ticket)
}
inline ::se::lobby::MatchTicket* S_MatchQueueEnterRes::release_ticket() {
  
  ::se::lobby::MatchTicket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::lobby::MatchTicket* S_MatchQueueEnterRes::unsafe_arena_release_ticket() {
  // @@protoc_insertion_point(field_release:se.lobby.S_MatchQueueEnterRes.ticket)
  
  ::se::lobby::MatchTicket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
  return temp;
}
inline ::se::lobby::MatchTicket* S_MatchQueueEnterRes::_internal_mutable_ticket() {
  
  if (_impl_.ticket_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::lobby::MatchTicket>(GetArenaForAllocation());
    _impl_.ticket_ = p;
  }
  return _impl_.ticket_;
}
inline ::se::lobby::MatchTicket* S_MatchQueueEnterRes::mutable_ticket() {
  ::se::lobby::MatchTicket* _msg = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:se.lobby.S_MatchQueueEnterRes.ticket)
  return _msg;
}
inline void S_MatchQueueEnterRes::set_allocated_ticket(::se::lobby::MatchTicket* ticket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ticket_);
  }
  if (ticket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ticket));
    if (message_arena != submessage_arena) {
      ticket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ticket, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ticket_ = ticket;
  // @@protoc_insertion_point(field_set_allocated:se.lobby.S_MatchQueueEnterRes.ticket)
}

// -------------------------------------------------------------------

// C_MatchQueueCancelReq

// .se.lobby.MatchTicket ticket = 1;
inline bool C_MatchQueueCancelReq::_internal_has_ticket() const {
  return this != internal_default_instance() && _impl_.ticket_ != nullptr;
}
inline bool C_MatchQueueCancelReq::has_ticket() const {
  return _internal_has_ticket();
}
inline const ::se::lobby::MatchTicket& C_MatchQueueCancelReq::_internal_ticket() const {
  const ::se::lobby::MatchTicket* p = _impl_.ticket_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::lobby::MatchTicket&>(
      ::se::lobby::_MatchTicket_default_instance_);
}
inline const ::se::lobby::MatchTicket& C_MatchQueueCancelReq::ticket() const {
  // @@protoc_insertion_point(field_get:se.lobby.C_MatchQueueCancelReq.ticket)
  return _internal_ticket();
}
inline void C_MatchQueueCancelReq::unsafe_arena_set_allocated_ticket(
    ::se::lobby::MatchTicket* ticket) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ticket_);
  }
  _impl_.ticket_ = ticket;
  if (ticket) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.lobby.C_MatchQueueCancelReq.ticket)
}
inline ::se::lobby::MatchTicket* C_MatchQueueCancelReq::release_ticket() {
  
  ::se::lobby::MatchTicket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::lobby::MatchTicket* C_MatchQueueCancelReq::unsafe_arena_release_ticket() {
  // @@protoc_insertion_point(field_release:se.lobby.C_MatchQueueCancelReq.ticket)
  
  ::se::lobby::MatchTicket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
  return temp;
}
inline ::se::lobby::MatchTicket* C_MatchQueueCancelReq::_internal_mutable_ticket() {
  
  if (_impl_.ticket_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::lobby::MatchTicket>(GetArenaForAllocation());
    _impl_.ticket_ = p;
  }
  return _impl_.ticket_;
}
inline ::se::lobby::MatchTicket* C_MatchQueueCancelReq::mutable_ticket() {
  ::se::lobby::MatchTicket* _msg = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:se.lobby.C_MatchQueueCancelReq.ticket)
  return _msg;
}
inline void C_MatchQueueCancelReq::set_allocated_ticket(::se::lobby::MatchTicket* ticket) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ticket_);
  }
  if (ticket) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ticket));
    if (message_arena != submessage_arena) {
      ticket = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ticket, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ticket_ = ticket;
  // @@protoc_insertion_point(field_set_allocated:se.lobby.C_MatchQueueCancelReq.ticket)
}

// -------------------------------------------------------------------

// S_MatchQueueCancelRes

// .se.common.Result result = 1;
inline bool S_MatchQueueCancelRes::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool S_MatchQueueCancelRes::has_result() const {
  return _internal_has_result();
}
inline const ::se::common::Result& S_MatchQueueCancelRes::_internal_result() const {
  const ::se::common::Result* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::common::Result&>(
      ::se::common::_Result_default_instance_);
}
inline const ::se::common::Result& S_MatchQueueCancelRes::result() const {
  // @@protoc_insertion_point(field_get:se.lobby.S_MatchQueueCancelRes.result)
  return _internal_result();
}
inline void S_MatchQueueCancelRes::unsafe_arena_set_allocated_result(
    ::se::common::Result* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.lobby.S_MatchQueueCancelRes.result)
}
inline ::se::common::Result* S_MatchQueueCancelRes::release_result() {
  
  ::se::common::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::common::Result* S_MatchQueueCancelRes::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:se.lobby.S_MatchQueueCancelRes.result)
  
  ::se::common::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::se::common::Result* S_MatchQueueCancelRes::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::common::Result>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::se::common::Result* S_MatchQueueCancelRes::mutable_result() {
  ::se::common::Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:se.lobby.S_MatchQueueCancelRes.result)
  return _msg;
}
inline void S_MatchQueueCancelRes::set_allocated_result(::se::common::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result));
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:se.lobby.S_MatchQueueCancelRes.result)
}

// -------------------------------------------------------------------

// N_MatchFound

// .se.lobby.RoomEndpoint room = 1;
inline bool N_MatchFound::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool N_MatchFound::has_room() const {
  return _internal_has_room();
}
inline const ::se::lobby::RoomEndpoint& N_MatchFound::_internal_room() const {
  const ::se::lobby::RoomEndpoint* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::lobby::RoomEndpoint&>(
      ::se::lobby::_RoomEndpoint_default_instance_);
}
inline const ::se::lobby::RoomEndpoint& N_MatchFound::room() const {
  // @@protoc_insertion_point(field_get:se.lobby.N_MatchFound.room)
  return _internal_room();
}
inline void N_MatchFound::unsafe_arena_set_allocated_room(
    ::se::lobby::RoomEndpoint* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.lobby.N_MatchFound.room)
}
inline ::se::lobby::RoomEndpoint* N_MatchFound::release_room() {
  
  ::se::lobby::RoomEndpoint* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::lobby::RoomEndpoint* N_MatchFound::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:se.lobby.N_MatchFound.room)
  
  ::se::lobby::RoomEndpoint* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::se::lobby::RoomEndpoint* N_MatchFound::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::lobby::RoomEndpoint>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::se::lobby::RoomEndpoint* N_MatchFound::mutable_room() {
  ::se::lobby::RoomEndpoint* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:se.lobby.N_MatchFound.room)
  return _msg;
}
inline void N_MatchFound::set_allocated_room(::se::lobby::RoomEndpoint* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:se.lobby.N_MatchFound.room)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lobby
}  // namespace se

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_lobby_2flobby_5fmessages_2eproto
