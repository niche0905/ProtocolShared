// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: room/messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_room_2fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_room_2fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "options/packet_options.pb.h"
#include "common/common_types.pb.h"
#include "room/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_room_2fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_room_2fmessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_room_2fmessages_2eproto;
namespace se {
namespace room {
class C_AimInput;
struct C_AimInputDefaultTypeInternal;
extern C_AimInputDefaultTypeInternal _C_AimInput_default_instance_;
class C_FireReq;
struct C_FireReqDefaultTypeInternal;
extern C_FireReqDefaultTypeInternal _C_FireReq_default_instance_;
class C_MoveInput;
struct C_MoveInputDefaultTypeInternal;
extern C_MoveInputDefaultTypeInternal _C_MoveInput_default_instance_;
class C_RoomReadyReq;
struct C_RoomReadyReqDefaultTypeInternal;
extern C_RoomReadyReqDefaultTypeInternal _C_RoomReadyReq_default_instance_;
class N_EntityDespawn;
struct N_EntityDespawnDefaultTypeInternal;
extern N_EntityDespawnDefaultTypeInternal _N_EntityDespawn_default_instance_;
class N_EntitySpawn;
struct N_EntitySpawnDefaultTypeInternal;
extern N_EntitySpawnDefaultTypeInternal _N_EntitySpawn_default_instance_;
class N_GameStart;
struct N_GameStartDefaultTypeInternal;
extern N_GameStartDefaultTypeInternal _N_GameStart_default_instance_;
class N_HitEvent;
struct N_HitEventDefaultTypeInternal;
extern N_HitEventDefaultTypeInternal _N_HitEvent_default_instance_;
class N_RoomReadyChanged;
struct N_RoomReadyChangedDefaultTypeInternal;
extern N_RoomReadyChangedDefaultTypeInternal _N_RoomReadyChanged_default_instance_;
class S_EntityState;
struct S_EntityStateDefaultTypeInternal;
extern S_EntityStateDefaultTypeInternal _S_EntityState_default_instance_;
}  // namespace room
}  // namespace se
PROTOBUF_NAMESPACE_OPEN
template<> ::se::room::C_AimInput* Arena::CreateMaybeMessage<::se::room::C_AimInput>(Arena*);
template<> ::se::room::C_FireReq* Arena::CreateMaybeMessage<::se::room::C_FireReq>(Arena*);
template<> ::se::room::C_MoveInput* Arena::CreateMaybeMessage<::se::room::C_MoveInput>(Arena*);
template<> ::se::room::C_RoomReadyReq* Arena::CreateMaybeMessage<::se::room::C_RoomReadyReq>(Arena*);
template<> ::se::room::N_EntityDespawn* Arena::CreateMaybeMessage<::se::room::N_EntityDespawn>(Arena*);
template<> ::se::room::N_EntitySpawn* Arena::CreateMaybeMessage<::se::room::N_EntitySpawn>(Arena*);
template<> ::se::room::N_GameStart* Arena::CreateMaybeMessage<::se::room::N_GameStart>(Arena*);
template<> ::se::room::N_HitEvent* Arena::CreateMaybeMessage<::se::room::N_HitEvent>(Arena*);
template<> ::se::room::N_RoomReadyChanged* Arena::CreateMaybeMessage<::se::room::N_RoomReadyChanged>(Arena*);
template<> ::se::room::S_EntityState* Arena::CreateMaybeMessage<::se::room::S_EntityState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace se {
namespace room {

// ===================================================================

class C_RoomReadyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.C_RoomReadyReq) */ {
 public:
  inline C_RoomReadyReq() : C_RoomReadyReq(nullptr) {}
  ~C_RoomReadyReq() override;
  explicit PROTOBUF_CONSTEXPR C_RoomReadyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_RoomReadyReq(const C_RoomReadyReq& from);
  C_RoomReadyReq(C_RoomReadyReq&& from) noexcept
    : C_RoomReadyReq() {
    *this = ::std::move(from);
  }

  inline C_RoomReadyReq& operator=(const C_RoomReadyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_RoomReadyReq& operator=(C_RoomReadyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_RoomReadyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_RoomReadyReq* internal_default_instance() {
    return reinterpret_cast<const C_RoomReadyReq*>(
               &_C_RoomReadyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_RoomReadyReq& a, C_RoomReadyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_RoomReadyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_RoomReadyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_RoomReadyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_RoomReadyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_RoomReadyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_RoomReadyReq& from) {
    C_RoomReadyReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_RoomReadyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.C_RoomReadyReq";
  }
  protected:
  explicit C_RoomReadyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // bool ready = 1;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:se.room.C_RoomReadyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class N_RoomReadyChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.N_RoomReadyChanged) */ {
 public:
  inline N_RoomReadyChanged() : N_RoomReadyChanged(nullptr) {}
  ~N_RoomReadyChanged() override;
  explicit PROTOBUF_CONSTEXPR N_RoomReadyChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  N_RoomReadyChanged(const N_RoomReadyChanged& from);
  N_RoomReadyChanged(N_RoomReadyChanged&& from) noexcept
    : N_RoomReadyChanged() {
    *this = ::std::move(from);
  }

  inline N_RoomReadyChanged& operator=(const N_RoomReadyChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline N_RoomReadyChanged& operator=(N_RoomReadyChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const N_RoomReadyChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const N_RoomReadyChanged* internal_default_instance() {
    return reinterpret_cast<const N_RoomReadyChanged*>(
               &_N_RoomReadyChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(N_RoomReadyChanged& a, N_RoomReadyChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(N_RoomReadyChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(N_RoomReadyChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  N_RoomReadyChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<N_RoomReadyChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const N_RoomReadyChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const N_RoomReadyChanged& from) {
    N_RoomReadyChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(N_RoomReadyChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.N_RoomReadyChanged";
  }
  protected:
  explicit N_RoomReadyChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kReadyFieldNumber = 2,
  };
  // .se.common.EntityId entity_id = 1;
  bool has_entity_id() const;
  private:
  bool _internal_has_entity_id() const;
  public:
  void clear_entity_id();
  const ::se::common::EntityId& entity_id() const;
  PROTOBUF_NODISCARD ::se::common::EntityId* release_entity_id();
  ::se::common::EntityId* mutable_entity_id();
  void set_allocated_entity_id(::se::common::EntityId* entity_id);
  private:
  const ::se::common::EntityId& _internal_entity_id() const;
  ::se::common::EntityId* _internal_mutable_entity_id();
  public:
  void unsafe_arena_set_allocated_entity_id(
      ::se::common::EntityId* entity_id);
  ::se::common::EntityId* unsafe_arena_release_entity_id();

  // bool ready = 2;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:se.room.N_RoomReadyChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::common::EntityId* entity_id_;
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class N_GameStart final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:se.room.N_GameStart) */ {
 public:
  inline N_GameStart() : N_GameStart(nullptr) {}
  explicit PROTOBUF_CONSTEXPR N_GameStart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  N_GameStart(const N_GameStart& from);
  N_GameStart(N_GameStart&& from) noexcept
    : N_GameStart() {
    *this = ::std::move(from);
  }

  inline N_GameStart& operator=(const N_GameStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline N_GameStart& operator=(N_GameStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const N_GameStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const N_GameStart* internal_default_instance() {
    return reinterpret_cast<const N_GameStart*>(
               &_N_GameStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(N_GameStart& a, N_GameStart& b) {
    a.Swap(&b);
  }
  inline void Swap(N_GameStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(N_GameStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  N_GameStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<N_GameStart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const N_GameStart& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const N_GameStart& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.N_GameStart";
  }
  protected:
  explicit N_GameStart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:se.room.N_GameStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class C_MoveInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.C_MoveInput) */ {
 public:
  inline C_MoveInput() : C_MoveInput(nullptr) {}
  ~C_MoveInput() override;
  explicit PROTOBUF_CONSTEXPR C_MoveInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MoveInput(const C_MoveInput& from);
  C_MoveInput(C_MoveInput&& from) noexcept
    : C_MoveInput() {
    *this = ::std::move(from);
  }

  inline C_MoveInput& operator=(const C_MoveInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MoveInput& operator=(C_MoveInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MoveInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MoveInput* internal_default_instance() {
    return reinterpret_cast<const C_MoveInput*>(
               &_C_MoveInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(C_MoveInput& a, C_MoveInput& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MoveInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MoveInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MoveInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MoveInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MoveInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MoveInput& from) {
    C_MoveInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MoveInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.C_MoveInput";
  }
  protected:
  explicit C_MoveInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveXFieldNumber = 1,
    kMoveYFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // float move_x = 1;
  void clear_move_x();
  float move_x() const;
  void set_move_x(float value);
  private:
  float _internal_move_x() const;
  void _internal_set_move_x(float value);
  public:

  // float move_y = 2;
  void clear_move_y();
  float move_y() const;
  void set_move_y(float value);
  private:
  float _internal_move_y() const;
  void _internal_set_move_y(float value);
  public:

  // float yaw = 3;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:se.room.C_MoveInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float move_x_;
    float move_y_;
    float yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class C_AimInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.C_AimInput) */ {
 public:
  inline C_AimInput() : C_AimInput(nullptr) {}
  ~C_AimInput() override;
  explicit PROTOBUF_CONSTEXPR C_AimInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_AimInput(const C_AimInput& from);
  C_AimInput(C_AimInput&& from) noexcept
    : C_AimInput() {
    *this = ::std::move(from);
  }

  inline C_AimInput& operator=(const C_AimInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_AimInput& operator=(C_AimInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_AimInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_AimInput* internal_default_instance() {
    return reinterpret_cast<const C_AimInput*>(
               &_C_AimInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_AimInput& a, C_AimInput& b) {
    a.Swap(&b);
  }
  inline void Swap(C_AimInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_AimInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_AimInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_AimInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_AimInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_AimInput& from) {
    C_AimInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_AimInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.C_AimInput";
  }
  protected:
  explicit C_AimInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPitchFieldNumber = 1,
  };
  // float pitch = 1;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // @@protoc_insertion_point(class_scope:se.room.C_AimInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float pitch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class C_FireReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.C_FireReq) */ {
 public:
  inline C_FireReq() : C_FireReq(nullptr) {}
  ~C_FireReq() override;
  explicit PROTOBUF_CONSTEXPR C_FireReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_FireReq(const C_FireReq& from);
  C_FireReq(C_FireReq&& from) noexcept
    : C_FireReq() {
    *this = ::std::move(from);
  }

  inline C_FireReq& operator=(const C_FireReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_FireReq& operator=(C_FireReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_FireReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_FireReq* internal_default_instance() {
    return reinterpret_cast<const C_FireReq*>(
               &_C_FireReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_FireReq& a, C_FireReq& b) {
    a.Swap(&b);
  }
  inline void Swap(C_FireReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_FireReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_FireReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_FireReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_FireReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_FireReq& from) {
    C_FireReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_FireReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.C_FireReq";
  }
  protected:
  explicit C_FireReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeaponIdFieldNumber = 1,
  };
  // uint32 weapon_id = 1;
  void clear_weapon_id();
  uint32_t weapon_id() const;
  void set_weapon_id(uint32_t value);
  private:
  uint32_t _internal_weapon_id() const;
  void _internal_set_weapon_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:se.room.C_FireReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t weapon_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class S_EntityState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.S_EntityState) */ {
 public:
  inline S_EntityState() : S_EntityState(nullptr) {}
  ~S_EntityState() override;
  explicit PROTOBUF_CONSTEXPR S_EntityState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EntityState(const S_EntityState& from);
  S_EntityState(S_EntityState&& from) noexcept
    : S_EntityState() {
    *this = ::std::move(from);
  }

  inline S_EntityState& operator=(const S_EntityState& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EntityState& operator=(S_EntityState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EntityState& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EntityState* internal_default_instance() {
    return reinterpret_cast<const S_EntityState*>(
               &_S_EntityState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_EntityState& a, S_EntityState& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EntityState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EntityState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EntityState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EntityState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EntityState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EntityState& from) {
    S_EntityState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EntityState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.S_EntityState";
  }
  protected:
  explicit S_EntityState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntitiesFieldNumber = 1,
  };
  // repeated .se.room.EntityState entities = 1;
  int entities_size() const;
  private:
  int _internal_entities_size() const;
  public:
  void clear_entities();
  ::se::room::EntityState* mutable_entities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::se::room::EntityState >*
      mutable_entities();
  private:
  const ::se::room::EntityState& _internal_entities(int index) const;
  ::se::room::EntityState* _internal_add_entities();
  public:
  const ::se::room::EntityState& entities(int index) const;
  ::se::room::EntityState* add_entities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::se::room::EntityState >&
      entities() const;

  // @@protoc_insertion_point(class_scope:se.room.S_EntityState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::se::room::EntityState > entities_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class N_EntitySpawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.N_EntitySpawn) */ {
 public:
  inline N_EntitySpawn() : N_EntitySpawn(nullptr) {}
  ~N_EntitySpawn() override;
  explicit PROTOBUF_CONSTEXPR N_EntitySpawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  N_EntitySpawn(const N_EntitySpawn& from);
  N_EntitySpawn(N_EntitySpawn&& from) noexcept
    : N_EntitySpawn() {
    *this = ::std::move(from);
  }

  inline N_EntitySpawn& operator=(const N_EntitySpawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline N_EntitySpawn& operator=(N_EntitySpawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const N_EntitySpawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const N_EntitySpawn* internal_default_instance() {
    return reinterpret_cast<const N_EntitySpawn*>(
               &_N_EntitySpawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(N_EntitySpawn& a, N_EntitySpawn& b) {
    a.Swap(&b);
  }
  inline void Swap(N_EntitySpawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(N_EntitySpawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  N_EntitySpawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<N_EntitySpawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const N_EntitySpawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const N_EntitySpawn& from) {
    N_EntitySpawn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(N_EntitySpawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.N_EntitySpawn";
  }
  protected:
  explicit N_EntitySpawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityFieldNumber = 1,
  };
  // .se.room.EntityState entity = 1;
  bool has_entity() const;
  private:
  bool _internal_has_entity() const;
  public:
  void clear_entity();
  const ::se::room::EntityState& entity() const;
  PROTOBUF_NODISCARD ::se::room::EntityState* release_entity();
  ::se::room::EntityState* mutable_entity();
  void set_allocated_entity(::se::room::EntityState* entity);
  private:
  const ::se::room::EntityState& _internal_entity() const;
  ::se::room::EntityState* _internal_mutable_entity();
  public:
  void unsafe_arena_set_allocated_entity(
      ::se::room::EntityState* entity);
  ::se::room::EntityState* unsafe_arena_release_entity();

  // @@protoc_insertion_point(class_scope:se.room.N_EntitySpawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::room::EntityState* entity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class N_EntityDespawn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.N_EntityDespawn) */ {
 public:
  inline N_EntityDespawn() : N_EntityDespawn(nullptr) {}
  ~N_EntityDespawn() override;
  explicit PROTOBUF_CONSTEXPR N_EntityDespawn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  N_EntityDespawn(const N_EntityDespawn& from);
  N_EntityDespawn(N_EntityDespawn&& from) noexcept
    : N_EntityDespawn() {
    *this = ::std::move(from);
  }

  inline N_EntityDespawn& operator=(const N_EntityDespawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline N_EntityDespawn& operator=(N_EntityDespawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const N_EntityDespawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const N_EntityDespawn* internal_default_instance() {
    return reinterpret_cast<const N_EntityDespawn*>(
               &_N_EntityDespawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(N_EntityDespawn& a, N_EntityDespawn& b) {
    a.Swap(&b);
  }
  inline void Swap(N_EntityDespawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(N_EntityDespawn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  N_EntityDespawn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<N_EntityDespawn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const N_EntityDespawn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const N_EntityDespawn& from) {
    N_EntityDespawn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(N_EntityDespawn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.N_EntityDespawn";
  }
  protected:
  explicit N_EntityDespawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
  };
  // .se.common.EntityId entity_id = 1;
  bool has_entity_id() const;
  private:
  bool _internal_has_entity_id() const;
  public:
  void clear_entity_id();
  const ::se::common::EntityId& entity_id() const;
  PROTOBUF_NODISCARD ::se::common::EntityId* release_entity_id();
  ::se::common::EntityId* mutable_entity_id();
  void set_allocated_entity_id(::se::common::EntityId* entity_id);
  private:
  const ::se::common::EntityId& _internal_entity_id() const;
  ::se::common::EntityId* _internal_mutable_entity_id();
  public:
  void unsafe_arena_set_allocated_entity_id(
      ::se::common::EntityId* entity_id);
  ::se::common::EntityId* unsafe_arena_release_entity_id();

  // @@protoc_insertion_point(class_scope:se.room.N_EntityDespawn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::common::EntityId* entity_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class N_HitEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:se.room.N_HitEvent) */ {
 public:
  inline N_HitEvent() : N_HitEvent(nullptr) {}
  ~N_HitEvent() override;
  explicit PROTOBUF_CONSTEXPR N_HitEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  N_HitEvent(const N_HitEvent& from);
  N_HitEvent(N_HitEvent&& from) noexcept
    : N_HitEvent() {
    *this = ::std::move(from);
  }

  inline N_HitEvent& operator=(const N_HitEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline N_HitEvent& operator=(N_HitEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const N_HitEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const N_HitEvent* internal_default_instance() {
    return reinterpret_cast<const N_HitEvent*>(
               &_N_HitEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(N_HitEvent& a, N_HitEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(N_HitEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(N_HitEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  N_HitEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<N_HitEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const N_HitEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const N_HitEvent& from) {
    N_HitEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(N_HitEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "se.room.N_HitEvent";
  }
  protected:
  explicit N_HitEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackerFieldNumber = 1,
    kVictimFieldNumber = 2,
    kDamageFieldNumber = 3,
  };
  // .se.common.EntityId attacker = 1;
  bool has_attacker() const;
  private:
  bool _internal_has_attacker() const;
  public:
  void clear_attacker();
  const ::se::common::EntityId& attacker() const;
  PROTOBUF_NODISCARD ::se::common::EntityId* release_attacker();
  ::se::common::EntityId* mutable_attacker();
  void set_allocated_attacker(::se::common::EntityId* attacker);
  private:
  const ::se::common::EntityId& _internal_attacker() const;
  ::se::common::EntityId* _internal_mutable_attacker();
  public:
  void unsafe_arena_set_allocated_attacker(
      ::se::common::EntityId* attacker);
  ::se::common::EntityId* unsafe_arena_release_attacker();

  // .se.common.EntityId victim = 2;
  bool has_victim() const;
  private:
  bool _internal_has_victim() const;
  public:
  void clear_victim();
  const ::se::common::EntityId& victim() const;
  PROTOBUF_NODISCARD ::se::common::EntityId* release_victim();
  ::se::common::EntityId* mutable_victim();
  void set_allocated_victim(::se::common::EntityId* victim);
  private:
  const ::se::common::EntityId& _internal_victim() const;
  ::se::common::EntityId* _internal_mutable_victim();
  public:
  void unsafe_arena_set_allocated_victim(
      ::se::common::EntityId* victim);
  ::se::common::EntityId* unsafe_arena_release_victim();

  // uint32 damage = 3;
  void clear_damage();
  uint32_t damage() const;
  void set_damage(uint32_t value);
  private:
  uint32_t _internal_damage() const;
  void _internal_set_damage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:se.room.N_HitEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::se::common::EntityId* attacker_;
    ::se::common::EntityId* victim_;
    uint32_t damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_RoomReadyReq

// bool ready = 1;
inline void C_RoomReadyReq::clear_ready() {
  _impl_.ready_ = false;
}
inline bool C_RoomReadyReq::_internal_ready() const {
  return _impl_.ready_;
}
inline bool C_RoomReadyReq::ready() const {
  // @@protoc_insertion_point(field_get:se.room.C_RoomReadyReq.ready)
  return _internal_ready();
}
inline void C_RoomReadyReq::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void C_RoomReadyReq::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:se.room.C_RoomReadyReq.ready)
}

// -------------------------------------------------------------------

// N_RoomReadyChanged

// .se.common.EntityId entity_id = 1;
inline bool N_RoomReadyChanged::_internal_has_entity_id() const {
  return this != internal_default_instance() && _impl_.entity_id_ != nullptr;
}
inline bool N_RoomReadyChanged::has_entity_id() const {
  return _internal_has_entity_id();
}
inline const ::se::common::EntityId& N_RoomReadyChanged::_internal_entity_id() const {
  const ::se::common::EntityId* p = _impl_.entity_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::common::EntityId&>(
      ::se::common::_EntityId_default_instance_);
}
inline const ::se::common::EntityId& N_RoomReadyChanged::entity_id() const {
  // @@protoc_insertion_point(field_get:se.room.N_RoomReadyChanged.entity_id)
  return _internal_entity_id();
}
inline void N_RoomReadyChanged::unsafe_arena_set_allocated_entity_id(
    ::se::common::EntityId* entity_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entity_id_);
  }
  _impl_.entity_id_ = entity_id;
  if (entity_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.room.N_RoomReadyChanged.entity_id)
}
inline ::se::common::EntityId* N_RoomReadyChanged::release_entity_id() {
  
  ::se::common::EntityId* temp = _impl_.entity_id_;
  _impl_.entity_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::common::EntityId* N_RoomReadyChanged::unsafe_arena_release_entity_id() {
  // @@protoc_insertion_point(field_release:se.room.N_RoomReadyChanged.entity_id)
  
  ::se::common::EntityId* temp = _impl_.entity_id_;
  _impl_.entity_id_ = nullptr;
  return temp;
}
inline ::se::common::EntityId* N_RoomReadyChanged::_internal_mutable_entity_id() {
  
  if (_impl_.entity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::common::EntityId>(GetArenaForAllocation());
    _impl_.entity_id_ = p;
  }
  return _impl_.entity_id_;
}
inline ::se::common::EntityId* N_RoomReadyChanged::mutable_entity_id() {
  ::se::common::EntityId* _msg = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:se.room.N_RoomReadyChanged.entity_id)
  return _msg;
}
inline void N_RoomReadyChanged::set_allocated_entity_id(::se::common::EntityId* entity_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entity_id_);
  }
  if (entity_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entity_id));
    if (message_arena != submessage_arena) {
      entity_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entity_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.entity_id_ = entity_id;
  // @@protoc_insertion_point(field_set_allocated:se.room.N_RoomReadyChanged.entity_id)
}

// bool ready = 2;
inline void N_RoomReadyChanged::clear_ready() {
  _impl_.ready_ = false;
}
inline bool N_RoomReadyChanged::_internal_ready() const {
  return _impl_.ready_;
}
inline bool N_RoomReadyChanged::ready() const {
  // @@protoc_insertion_point(field_get:se.room.N_RoomReadyChanged.ready)
  return _internal_ready();
}
inline void N_RoomReadyChanged::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void N_RoomReadyChanged::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:se.room.N_RoomReadyChanged.ready)
}

// -------------------------------------------------------------------

// N_GameStart

// -------------------------------------------------------------------

// C_MoveInput

// float move_x = 1;
inline void C_MoveInput::clear_move_x() {
  _impl_.move_x_ = 0;
}
inline float C_MoveInput::_internal_move_x() const {
  return _impl_.move_x_;
}
inline float C_MoveInput::move_x() const {
  // @@protoc_insertion_point(field_get:se.room.C_MoveInput.move_x)
  return _internal_move_x();
}
inline void C_MoveInput::_internal_set_move_x(float value) {
  
  _impl_.move_x_ = value;
}
inline void C_MoveInput::set_move_x(float value) {
  _internal_set_move_x(value);
  // @@protoc_insertion_point(field_set:se.room.C_MoveInput.move_x)
}

// float move_y = 2;
inline void C_MoveInput::clear_move_y() {
  _impl_.move_y_ = 0;
}
inline float C_MoveInput::_internal_move_y() const {
  return _impl_.move_y_;
}
inline float C_MoveInput::move_y() const {
  // @@protoc_insertion_point(field_get:se.room.C_MoveInput.move_y)
  return _internal_move_y();
}
inline void C_MoveInput::_internal_set_move_y(float value) {
  
  _impl_.move_y_ = value;
}
inline void C_MoveInput::set_move_y(float value) {
  _internal_set_move_y(value);
  // @@protoc_insertion_point(field_set:se.room.C_MoveInput.move_y)
}

// float yaw = 3;
inline void C_MoveInput::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float C_MoveInput::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float C_MoveInput::yaw() const {
  // @@protoc_insertion_point(field_get:se.room.C_MoveInput.yaw)
  return _internal_yaw();
}
inline void C_MoveInput::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void C_MoveInput::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:se.room.C_MoveInput.yaw)
}

// -------------------------------------------------------------------

// C_AimInput

// float pitch = 1;
inline void C_AimInput::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float C_AimInput::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float C_AimInput::pitch() const {
  // @@protoc_insertion_point(field_get:se.room.C_AimInput.pitch)
  return _internal_pitch();
}
inline void C_AimInput::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void C_AimInput::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:se.room.C_AimInput.pitch)
}

// -------------------------------------------------------------------

// C_FireReq

// uint32 weapon_id = 1;
inline void C_FireReq::clear_weapon_id() {
  _impl_.weapon_id_ = 0u;
}
inline uint32_t C_FireReq::_internal_weapon_id() const {
  return _impl_.weapon_id_;
}
inline uint32_t C_FireReq::weapon_id() const {
  // @@protoc_insertion_point(field_get:se.room.C_FireReq.weapon_id)
  return _internal_weapon_id();
}
inline void C_FireReq::_internal_set_weapon_id(uint32_t value) {
  
  _impl_.weapon_id_ = value;
}
inline void C_FireReq::set_weapon_id(uint32_t value) {
  _internal_set_weapon_id(value);
  // @@protoc_insertion_point(field_set:se.room.C_FireReq.weapon_id)
}

// -------------------------------------------------------------------

// S_EntityState

// repeated .se.room.EntityState entities = 1;
inline int S_EntityState::_internal_entities_size() const {
  return _impl_.entities_.size();
}
inline int S_EntityState::entities_size() const {
  return _internal_entities_size();
}
inline ::se::room::EntityState* S_EntityState::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:se.room.S_EntityState.entities)
  return _impl_.entities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::se::room::EntityState >*
S_EntityState::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:se.room.S_EntityState.entities)
  return &_impl_.entities_;
}
inline const ::se::room::EntityState& S_EntityState::_internal_entities(int index) const {
  return _impl_.entities_.Get(index);
}
inline const ::se::room::EntityState& S_EntityState::entities(int index) const {
  // @@protoc_insertion_point(field_get:se.room.S_EntityState.entities)
  return _internal_entities(index);
}
inline ::se::room::EntityState* S_EntityState::_internal_add_entities() {
  return _impl_.entities_.Add();
}
inline ::se::room::EntityState* S_EntityState::add_entities() {
  ::se::room::EntityState* _add = _internal_add_entities();
  // @@protoc_insertion_point(field_add:se.room.S_EntityState.entities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::se::room::EntityState >&
S_EntityState::entities() const {
  // @@protoc_insertion_point(field_list:se.room.S_EntityState.entities)
  return _impl_.entities_;
}

// -------------------------------------------------------------------

// N_EntitySpawn

// .se.room.EntityState entity = 1;
inline bool N_EntitySpawn::_internal_has_entity() const {
  return this != internal_default_instance() && _impl_.entity_ != nullptr;
}
inline bool N_EntitySpawn::has_entity() const {
  return _internal_has_entity();
}
inline const ::se::room::EntityState& N_EntitySpawn::_internal_entity() const {
  const ::se::room::EntityState* p = _impl_.entity_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::room::EntityState&>(
      ::se::room::_EntityState_default_instance_);
}
inline const ::se::room::EntityState& N_EntitySpawn::entity() const {
  // @@protoc_insertion_point(field_get:se.room.N_EntitySpawn.entity)
  return _internal_entity();
}
inline void N_EntitySpawn::unsafe_arena_set_allocated_entity(
    ::se::room::EntityState* entity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entity_);
  }
  _impl_.entity_ = entity;
  if (entity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.room.N_EntitySpawn.entity)
}
inline ::se::room::EntityState* N_EntitySpawn::release_entity() {
  
  ::se::room::EntityState* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::room::EntityState* N_EntitySpawn::unsafe_arena_release_entity() {
  // @@protoc_insertion_point(field_release:se.room.N_EntitySpawn.entity)
  
  ::se::room::EntityState* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
  return temp;
}
inline ::se::room::EntityState* N_EntitySpawn::_internal_mutable_entity() {
  
  if (_impl_.entity_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::room::EntityState>(GetArenaForAllocation());
    _impl_.entity_ = p;
  }
  return _impl_.entity_;
}
inline ::se::room::EntityState* N_EntitySpawn::mutable_entity() {
  ::se::room::EntityState* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:se.room.N_EntitySpawn.entity)
  return _msg;
}
inline void N_EntitySpawn::set_allocated_entity(::se::room::EntityState* entity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entity_);
  }
  if (entity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entity));
    if (message_arena != submessage_arena) {
      entity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.entity_ = entity;
  // @@protoc_insertion_point(field_set_allocated:se.room.N_EntitySpawn.entity)
}

// -------------------------------------------------------------------

// N_EntityDespawn

// .se.common.EntityId entity_id = 1;
inline bool N_EntityDespawn::_internal_has_entity_id() const {
  return this != internal_default_instance() && _impl_.entity_id_ != nullptr;
}
inline bool N_EntityDespawn::has_entity_id() const {
  return _internal_has_entity_id();
}
inline const ::se::common::EntityId& N_EntityDespawn::_internal_entity_id() const {
  const ::se::common::EntityId* p = _impl_.entity_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::common::EntityId&>(
      ::se::common::_EntityId_default_instance_);
}
inline const ::se::common::EntityId& N_EntityDespawn::entity_id() const {
  // @@protoc_insertion_point(field_get:se.room.N_EntityDespawn.entity_id)
  return _internal_entity_id();
}
inline void N_EntityDespawn::unsafe_arena_set_allocated_entity_id(
    ::se::common::EntityId* entity_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entity_id_);
  }
  _impl_.entity_id_ = entity_id;
  if (entity_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.room.N_EntityDespawn.entity_id)
}
inline ::se::common::EntityId* N_EntityDespawn::release_entity_id() {
  
  ::se::common::EntityId* temp = _impl_.entity_id_;
  _impl_.entity_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::common::EntityId* N_EntityDespawn::unsafe_arena_release_entity_id() {
  // @@protoc_insertion_point(field_release:se.room.N_EntityDespawn.entity_id)
  
  ::se::common::EntityId* temp = _impl_.entity_id_;
  _impl_.entity_id_ = nullptr;
  return temp;
}
inline ::se::common::EntityId* N_EntityDespawn::_internal_mutable_entity_id() {
  
  if (_impl_.entity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::common::EntityId>(GetArenaForAllocation());
    _impl_.entity_id_ = p;
  }
  return _impl_.entity_id_;
}
inline ::se::common::EntityId* N_EntityDespawn::mutable_entity_id() {
  ::se::common::EntityId* _msg = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:se.room.N_EntityDespawn.entity_id)
  return _msg;
}
inline void N_EntityDespawn::set_allocated_entity_id(::se::common::EntityId* entity_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.entity_id_);
  }
  if (entity_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(entity_id));
    if (message_arena != submessage_arena) {
      entity_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entity_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.entity_id_ = entity_id;
  // @@protoc_insertion_point(field_set_allocated:se.room.N_EntityDespawn.entity_id)
}

// -------------------------------------------------------------------

// N_HitEvent

// .se.common.EntityId attacker = 1;
inline bool N_HitEvent::_internal_has_attacker() const {
  return this != internal_default_instance() && _impl_.attacker_ != nullptr;
}
inline bool N_HitEvent::has_attacker() const {
  return _internal_has_attacker();
}
inline const ::se::common::EntityId& N_HitEvent::_internal_attacker() const {
  const ::se::common::EntityId* p = _impl_.attacker_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::common::EntityId&>(
      ::se::common::_EntityId_default_instance_);
}
inline const ::se::common::EntityId& N_HitEvent::attacker() const {
  // @@protoc_insertion_point(field_get:se.room.N_HitEvent.attacker)
  return _internal_attacker();
}
inline void N_HitEvent::unsafe_arena_set_allocated_attacker(
    ::se::common::EntityId* attacker) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attacker_);
  }
  _impl_.attacker_ = attacker;
  if (attacker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.room.N_HitEvent.attacker)
}
inline ::se::common::EntityId* N_HitEvent::release_attacker() {
  
  ::se::common::EntityId* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::common::EntityId* N_HitEvent::unsafe_arena_release_attacker() {
  // @@protoc_insertion_point(field_release:se.room.N_HitEvent.attacker)
  
  ::se::common::EntityId* temp = _impl_.attacker_;
  _impl_.attacker_ = nullptr;
  return temp;
}
inline ::se::common::EntityId* N_HitEvent::_internal_mutable_attacker() {
  
  if (_impl_.attacker_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::common::EntityId>(GetArenaForAllocation());
    _impl_.attacker_ = p;
  }
  return _impl_.attacker_;
}
inline ::se::common::EntityId* N_HitEvent::mutable_attacker() {
  ::se::common::EntityId* _msg = _internal_mutable_attacker();
  // @@protoc_insertion_point(field_mutable:se.room.N_HitEvent.attacker)
  return _msg;
}
inline void N_HitEvent::set_allocated_attacker(::se::common::EntityId* attacker) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attacker_);
  }
  if (attacker) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attacker));
    if (message_arena != submessage_arena) {
      attacker = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attacker, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attacker_ = attacker;
  // @@protoc_insertion_point(field_set_allocated:se.room.N_HitEvent.attacker)
}

// .se.common.EntityId victim = 2;
inline bool N_HitEvent::_internal_has_victim() const {
  return this != internal_default_instance() && _impl_.victim_ != nullptr;
}
inline bool N_HitEvent::has_victim() const {
  return _internal_has_victim();
}
inline const ::se::common::EntityId& N_HitEvent::_internal_victim() const {
  const ::se::common::EntityId* p = _impl_.victim_;
  return p != nullptr ? *p : reinterpret_cast<const ::se::common::EntityId&>(
      ::se::common::_EntityId_default_instance_);
}
inline const ::se::common::EntityId& N_HitEvent::victim() const {
  // @@protoc_insertion_point(field_get:se.room.N_HitEvent.victim)
  return _internal_victim();
}
inline void N_HitEvent::unsafe_arena_set_allocated_victim(
    ::se::common::EntityId* victim) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.victim_);
  }
  _impl_.victim_ = victim;
  if (victim) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:se.room.N_HitEvent.victim)
}
inline ::se::common::EntityId* N_HitEvent::release_victim() {
  
  ::se::common::EntityId* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::se::common::EntityId* N_HitEvent::unsafe_arena_release_victim() {
  // @@protoc_insertion_point(field_release:se.room.N_HitEvent.victim)
  
  ::se::common::EntityId* temp = _impl_.victim_;
  _impl_.victim_ = nullptr;
  return temp;
}
inline ::se::common::EntityId* N_HitEvent::_internal_mutable_victim() {
  
  if (_impl_.victim_ == nullptr) {
    auto* p = CreateMaybeMessage<::se::common::EntityId>(GetArenaForAllocation());
    _impl_.victim_ = p;
  }
  return _impl_.victim_;
}
inline ::se::common::EntityId* N_HitEvent::mutable_victim() {
  ::se::common::EntityId* _msg = _internal_mutable_victim();
  // @@protoc_insertion_point(field_mutable:se.room.N_HitEvent.victim)
  return _msg;
}
inline void N_HitEvent::set_allocated_victim(::se::common::EntityId* victim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.victim_);
  }
  if (victim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(victim));
    if (message_arena != submessage_arena) {
      victim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, victim, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.victim_ = victim;
  // @@protoc_insertion_point(field_set_allocated:se.room.N_HitEvent.victim)
}

// uint32 damage = 3;
inline void N_HitEvent::clear_damage() {
  _impl_.damage_ = 0u;
}
inline uint32_t N_HitEvent::_internal_damage() const {
  return _impl_.damage_;
}
inline uint32_t N_HitEvent::damage() const {
  // @@protoc_insertion_point(field_get:se.room.N_HitEvent.damage)
  return _internal_damage();
}
inline void N_HitEvent::_internal_set_damage(uint32_t value) {
  
  _impl_.damage_ = value;
}
inline void N_HitEvent::set_damage(uint32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:se.room.N_HitEvent.damage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace room
}  // namespace se

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_room_2fmessages_2eproto
